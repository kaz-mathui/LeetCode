# 両方のコードの時間計算量を比較することで、どちらが速いかをロジカルに検証します。

# ### オリジナルのコード
# オリジナルのコードは、文字ごとに比較する方法を採用しています。

# #### 時間計算量
# 1. `zip(*strs)` は、すべての文字列の同じインデックスの文字をまとめるため、最長の文字列の長さを \(m\) とすると \(O(m)\) の操作です。
# 2. 各タプル内で全ての文字が同じかどうかをチェックするために、各タプルについて一度`set`を作成し、その長さをチェックします。各タプルの長さは文字列の数 \(n\) です。よって各タプルのチェックには \(O(n)\) がかかります。
# 3. 最長共通接頭辞の長さが \(m\) である場合、これをすべてのタプルに対して行うので、全体の計算量は \(O(m \cdot n)\) になります。

# ### 新しいアプローチのコード
# 新しいアプローチのコードは、最初の文字列を基準にして他の文字列と比較し、接頭辞が一致しなくなったら接頭辞を短くしていく方法です。

# #### 時間計算量
# 1. 最初の文字列の長さを \(m\) とし、他のすべての文字列と接頭辞を比較します。最悪の場合、全ての文字列の接頭辞を全体で比較する必要があります。
# 2. 各文字列について、接頭辞が一致しなくなるまでの比較が最大で \(m\) 回必要です。この操作を他の \(n-1\) 個の文字列に対して行うので、全体の計算量は \(O(m \cdot n)\) になります。

# ### 比較と結論
# 両方の方法の計算量は同じ \(O(m \cdot n)\) ですが、実際のパフォーマンスには以下の点が影響する可能性があります：

# - **オリジナルのコード**:
#   - 各タプルを `set` に変換するオーバーヘッドがあるため、特に文字列が長い場合、余計な計算が多くなります。
#   - 各文字の比較は一度に行われるため、早い段階で異なる文字が見つかる場合でも、すべての文字を比較する必要があります。

# - **新しいアプローチのコード**:
#   - 一致しない場合には接頭辞を短くするため、無駄な比較を減らせる可能性があります。
#   - 比較は一度に一つの文字列に対して行われるため、異なる文字が見つかった時点で早めに処理を終了できます。

# ### 結論
# 一般的には、新しいアプローチの方が実際のパフォーマンスが良い可能性があります。これは、早い段階で接頭辞が一致しない場合に早めに処理を終了し、不要な比較を避けられるためです。ただし、特定のケースによってはオリジナルの方法でも十分に効率的に動作することがあります。

class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        if not strs:
            return ""
        ans = ""
        print(*strs)
        for num in zip(*strs):
            print(num)
            if len(set(num)) == 1:
                ans += num[0]
            else:
                return ans
        return ans

    def longestCommonPrefix2(self, strs: list[str]) -> str:
        if not strs:
            return ""

        # 最初の文字列を基準にする
        prefix = strs[0]

        for s in strs[1:]:
            # 現在の接頭辞がsの先頭と一致する部分を探す
            while s[: len(prefix)] != prefix:
                # 一致しない場合、接頭辞を一文字ずつ短くする
                prefix = prefix[:-1]
                # 接頭辞が空になった場合、共通部分はないので空文字列を返す
                if not prefix:
                    return ""

        return prefix


def main():
    solution = Solution()
    strs = ["flower", "flow", "flight"]
    print("ans: ", solution.longestCommonPrefix2(strs))


if __name__ == "__main__":
    main()
